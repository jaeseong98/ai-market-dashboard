import React, { useEffect, useState, useMemo } from 'react'
import { Line } from 'react-chartjs-2'
import { Card, CardHeader, CardContent } from '../../../components/Card.js'
import { indicatorNames, indicatorColors } from '../../../helpers/indicators.js'
import {
    Chart as ChartJS,
    CategoryScale,
    LinearScale,
    PointElement,
    LineElement,
    Title,
    Tooltip,
    Legend,
    TimeScale,
    registerables,
} from 'chart.js'
import 'chartjs-adapter-date-fns'
import annotationPlugin from 'chartjs-plugin-annotation'
import { format, parseISO, isEqual } from 'date-fns'
import { ko } from 'date-fns/locale'
import { winsorizeData } from '../../../helpers/dataprocessing.js'

ChartJS.register(
    CategoryScale,
    LinearScale,
    PointElement,
    LineElement,
    Title,
    Tooltip,
    Legend,
    TimeScale,
    annotationPlugin,
    ...registerables,
)


// Í∏∞Ï°¥Ïùò TimeSeriesChart Ïª¥Ìè¨ÎÑåÌä∏
const TimeSeriesChart = ({ data, indicatorKey, nberData, onClose, isNormalized }) => {
    const [chartInstance, setChartInstance] = useState(null)
    const [showTrimmed, setShowTrimmed] = useState(false)

    useEffect(() => {
        return () => {
            if (chartInstance) {
                chartInstance.destroy()
            }
        }
    }, [chartInstance])

    const handleChartRef = (ref) => {
        if (ref) {
            setChartInstance(ref.chartInstance)
        }
    }

    // Îç∞Ïù¥ÌÑ∞ Ï†ÑÏ≤òÎ¶¨ Î∞è Ïú†Ìö®ÏÑ± Í≤ÄÏÇ¨
    const validData = data
        .filter((item) => item[indicatorKey] !== undefined && item[indicatorKey] !== null)
        .sort((a, b) => new Date(a.DATA_YMD) - new Date(b.DATA_YMD)) // ÎÇ†Ïßú Ïò§Î¶ÑÏ∞®Ïàú Ï†ïÎ†¨

    const trimmedData = winsorizeData(validData, indicatorKey)

    const values = validData.map(item => parseFloat(item[indicatorKey]))
    const min = Math.min(...values)
    const max = Math.max(...values)
    const mean = values.reduce((sum, value) => sum + value, 0) / values.length
    const std = Math.sqrt(values.reduce((sum, value) => sum + Math.pow(value - mean, 2), 0) / values.length)
    const upperBound = mean + 3 * std
    const lowerBound = mean - 3 * std

    const normalizeValue = (value) => (value - min) / (max - min)

    const chartData = {
        labels: validData.map((item) => item.DATA_YMD),
        datasets: [
            {
                label: `${indicatorNames[indicatorKey]} (Ïù¥ÏÉÅÏπò Ï†úÍ±∞)`,
                data: trimmedData.map((item) => isNormalized ? normalizeValue(item[`${indicatorKey}_winsorized`]) : item[`${indicatorKey}_winsorized`]),
                borderColor: 'rgb(255, 165, 0)',
                backgroundColor: 'rgba(255, 165, 0, 0.5)',
                borderWidth: 2, // ÏÑ† ÎëêÍªòÎ•º 1Î°ú ÏÑ§Ï†ï
                tension: 0.1,
                pointRadius: 1, // Ï†ê ÌÅ¨Í∏∞Î•º 1Î°ú Ï§ÑÏûÑ
                pointHoverRadius: 5, // Ìò∏Î≤Ñ Ïãú Ï†ê ÌÅ¨Í∏∞Î•º 3ÏúºÎ°ú Ï§ÑÏûÑ
                pointStyle: 'circle', // Ï†ê Ïä§ÌÉÄÏùºÏùÑ ÏõêÏúºÎ°ú Î≥ÄÍ≤Ω
                hidden: !showTrimmed,
            },
            {
                label: `${indicatorNames[indicatorKey]} (ÏõêÎ≥∏)`,
                data: validData.map((item) => isNormalized ? normalizeValue(parseFloat(item[indicatorKey])) : parseFloat(item[indicatorKey])),
                borderColor: 'rgb(135, 206, 235)',
                backgroundColor: 'rgba(135, 206, 235, 0.5)',
                borderWidth: 2, // ÏÑ† ÎëêÍªòÎ•º 1Î°ú ÏÑ§Ï†ï
                pointRadius: 0, // Ï†ê ÌÅ¨Í∏∞Î•º 1Î°ú Ï§ÑÏûÑ
                pointHoverRadius: 5, // Ìò∏Î≤Ñ Ïãú Ï†ê ÌÅ¨Í∏∞Î•º 3ÏúºÎ°ú Ï§ÑÏûÑ
                pointStyle: 'circle', // Ï†ê Ïä§ÌÉÄÏùºÏùÑ ÏõêÏúºÎ°ú Î≥Ä
            },
            {
                label: 'ÌèâÍ∑†',
                data: validData.map(() => isNormalized ? normalizeValue(mean) : mean),
                borderColor: 'rgb(255, 0, 0)',
                borderWidth: 2,
                borderDash: [5, 5],
                pointRadius: 0,
                fill: false,
            },
            {
                label: 'ÏÉÅÌïú (ÌèâÍ∑† + 3*ÌëúÏ§ÄÌé∏Ï∞®)',
                data: validData.map(() => isNormalized ? normalizeValue(upperBound) : upperBound),
                borderColor: 'rgb(0, 128, 0)',
                borderWidth: 2,
                borderDash: [5, 5],
                pointRadius: 0,
                fill: false,
            },
            {
                label: 'ÌïòÌïú (ÌèâÍ∑† - 3*ÌëúÏ§ÄÌé∏Ï∞®)',
                data: validData.map(() => isNormalized ? normalizeValue(lowerBound) : lowerBound),
                borderColor: 'rgb(0, 128, 0)',
                borderWidth: 2,
                borderDash: [5, 5],
                pointRadius: 0,
                fill: false,
            },
        ],
    }

    const options = {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
            legend: {
                display: true,
                position: 'top',
                onClick: (e, legendItem, legend) => {
                    const index = legendItem.datasetIndex
                    const ci = legend.chart
                    if (ci.isDatasetVisible(index)) {
                        ci.hide(index)
                        legendItem.hidden = false
                    } else {
                        ci.show(index)
                        legendItem.hidden = true
                    }
                    setShowTrimmed(ci.isDatasetVisible(1))
                },
                labels: {
                    color: 'rgb(156, 163, 175)', // Î≤îÎ°Ä ÌÖçÏä§Ìä∏ ÏÉâÏÉÅÏùÑ ÌöåÏÉâÏúºÎ°ú Î≥ÄÍ≤Ω (TailwindÏùò gray-400Ïóê Ìï¥Îãπ)
                    usePointStyle: true,
                    pointStyle: 'rectRounded',
                    font: {
                        size: 12 // Ìè∞Ìä∏ ÌÅ¨Í∏∞ Ï°∞Ï†ï (ÌïÑÏöîÏóê Îî∞Îùº)
                    },
                    boxWidth: 15, // Î≤îÎ°Ä ÏïÑÏù¥ÏΩòÏùò ÎÑàÎπÑ
                    boxHeight: 15, // Î≤îÎ°Ä ÏïÑÏù¥ÏΩòÏùò ÎÜíÏù¥
                },
            },
            tooltip: {
                mode: 'index',
                intersect: false,
                callbacks: {
                    title: (context) => {
                        const date = new Date(context[0].parsed.x)
                        return format(date, 'yyyy-MM-dd', { locale: ko })
                    },
                    label: (context) => {
                        let label = context.dataset.label || ''
                        if (label) {
                            label += ': '
                        }
                        if (context.parsed.y !== null) {
                            label += context.parsed.y.toFixed(2)
                        }
                        return label
                    },
                    afterBody: (context) => {
                        const date = new Date(context[0].parsed.x)
                        const formattedDate = format(date, 'yyyy-MM-dd')
                        const nberItem = nberData.find((item) => isEqual(parseISO(item.date), parseISO(formattedDate)))
                        if (nberItem && nberItem.isRecession) {
                            return 'üü• Í≤ΩÍ∏∞ Ïπ®Ï≤¥ Í∏∞Í∞Ñ' // Îπ®Í∞ÑÏÉâ ÎÑ§Î™® Ïù¥Î™®ÏßÄ ÏÇ¨Ïö©
                        }
                        return ''
                    },
                },
            },
            annotation: {
                annotations: nberData.reduce((acc, item, index, array) => {
                    if (item.isRecession && (!array[index - 1] || !array[index - 1].isRecession)) {
                        const endDate =
                            array.slice(index).find((i) => !i.isRecession)?.date || array[array.length - 1].date
                        acc.push({
                            type: 'box',
                            xMin: item.date,
                            xMax: endDate,
                            backgroundColor: 'rgba(255, 0, 0, 0.1)',
                            borderColor: 'rgba(255, 0, 0, 0.3)',
                            drawTime: 'beforeDatasetsDraw',
                        })
                    }
                    return acc
                }, []),
            },
        },
        scales: {
            x: {
                type: 'time',
                time: {
                    unit: 'month',
                    displayFormats: {
                        month: 'yyyy-MM',
                    },
                },

                title: {
                    display: true,
                    text: 'ÎÇ†Ïßú',
                },
            },
            y: {
                title: {
                    display: true,
                    text: isNormalized ? 'Ï†ïÍ∑úÌôîÎêú Í∞í' : 'Í∞í',
                },
                beginAtZero: isNormalized,
                min: isNormalized ? 0 : undefined,
                max: isNormalized ? 1 : undefined,
            },
        },
    }

    return (
        <Card className="fixed inset-0 z-50 bg-gray-900 bg-opacity-75 flex items-center justify-center">
            <div className="bg-gray-800 p-6 rounded-lg w-full max-w-4xl">
                <CardHeader className="flex justify-between items-center">
                    <h3 className="text-xl font-semibold text-white">{indicatorNames[indicatorKey]} ÏãúÍ≥ÑÏó¥ Í∑∏ÎûòÌîÑ</h3>
                    <div>
                        <button
                            onClick={() => setShowTrimmed(!showTrimmed)}
                            className="text-gray-400 hover:text-white mr-4"
                        >
                            {showTrimmed ? 'Ïù¥ÏÉÅÏπò Ï†úÍ±∞ Ïà®Í∏∞Í∏∞' : 'Ïù¥ÏÉÅÏπò Ï†úÍ±∞ Î≥¥Í∏∞'}
                        </button>
                        <button onClick={onClose} className="text-gray-400 hover:text-white">
                            Îã´Í∏∞
                        </button>
                    </div>
                </CardHeader>
                <CardContent>
                    <div style={{ height: '400px' }}>
                        {validData.length > 0 ? (
                            <Line ref={handleChartRef} data={chartData} options={options} />
                        ) : (
                            <p>Îç∞Ïù¥ÌÑ∞Î•º Î∂àÎü¨Ïò§Îäî Ï§ëÏûÖÎãàÎã§...</p>
                        )}
                    </div>
                </CardContent>
            </div>
        </Card>
    )
}

// ÏÉàÎ°úÏö¥ CompareChart Ïª¥Ìè¨ÎÑåÌä∏
const CompareChart = ({ data, selectedIndicators, nberData, onClose }) => {
    const [chartInstance, setChartInstance] = useState(null)
    const [isNormalized, setIsNormalized] = useState(false)


    useEffect(() => {
        return () => {
            if (chartInstance) {
                chartInstance.destroy()
            }
        }
    }, [chartInstance])

    const handleChartRef = (ref) => {
        if (ref) {
            setChartInstance(ref.chartInstance)
        }
    }

    const processedData = useMemo(() => {
        const indicatorData = {}
        selectedIndicators.forEach((indicator) => {
            const values = data.map((item) => parseFloat(item[indicator])).filter((value) => !isNaN(value))
            if (isNormalized) {
                const min = Math.min(...values)
                const max = Math.max(...values)
                indicatorData[indicator] = {
                    values: values.map((value) => (value - min) / (max - min)),
                    min,
                    max,
                }
            } else {
                indicatorData[indicator] = { values }
            }
        })
        return indicatorData
    }, [data, selectedIndicators, isNormalized])

    const chartData = useMemo(() => ({
        labels: data.map((item) => item.DATA_YMD),
        datasets: selectedIndicators.map((indicator, index) => ({
            label: indicatorNames[indicator],
            data: processedData[indicator].values,
            borderColor: indicatorColors[indicator] || `hsl(${index * 137.5 % 360}, 70%, 50%)`,
            backgroundColor: indicatorColors[indicator] || `hsl(${index * 137.5 % 360}, 70%, 50%)`,
            borderWidth: 2, // ÏÑ† ÎëêÍªòÎ•º 1Î°ú ÏÑ§Ï†ï
            pointRadius: 0, // Ï†ê ÌÅ¨Í∏∞Î•º 1Î°ú Ï§ÑÏûÑ
            pointHoverRadius: 5, // Ìò∏Î≤Ñ Ïãú Ï†ê ÌÅ¨Í∏∞Î•º 3ÏúºÎ°ú Ï§ÑÏûÑ
            pointStyle: 'circle', // Ï†ê Ïä§ÌÉÄÏùºÏùÑ ÏõêÏúºÎ°ú Î≥ÄÍ≤Ω
            fill: false,
        })),
    }), [data, selectedIndicators, processedData])

    const options = useMemo(() => ({
        responsive: true,
        maintainAspectRatio: false,
        scales: {
            x: {
                type: 'time',
                time: {
                    unit: 'month',
                    displayFormats: {
                        month: 'yyyy-MM',
                    },
                },
                title: {
                    display: true,
                    text: 'ÎÇ†Ïßú',
                },
            },
            y: {
                title: {
                    display: true,
                    text: isNormalized ? 'Ï†ïÍ∑úÌôîÎêú Í∞í' : 'ÏõêÎûò Í∞í',
                },
                min: isNormalized ? 0 : undefined,
                max: isNormalized ? 1 : undefined,
            },
        },
        plugins: {
            tooltip: {
                mode: 'index',
                intersect: false,
                callbacks: {
                    title: function(tooltipItems) {
                        // ÎÇ†Ïßú ÌòïÏãùÏùÑ YYYY-MM-DDÎ°ú Î≥ÄÍ≤Ω
                        return format(new Date(tooltipItems[0].parsed.x), 'yyyy-MM-dd');
                    },
                    label: function(context) {
                        const indicator = selectedIndicators[context.datasetIndex];
                        const value = context.parsed.y;
                        return `${indicatorNames[indicator]}: ${value.toFixed(4)}`;
                    },
                    afterBody: (context) => {
                        const date = new Date(context[0].parsed.x);
                        const formattedDate = format(date, 'yyyy-MM-dd');
                        const nberItem = nberData.find((item) => isEqual(parseISO(item.date), parseISO(formattedDate)));
                        if (nberItem && nberItem.isRecession) {
                            return 'üü• Í≤ΩÍ∏∞ Ïπ®Ï≤¥ Í∏∞Í∞Ñ';
                        }
                        return '';
                    }
                }
            },
            legend: {
                display: true,
                position: 'top',
                labels: {
                    color: 'rgb(156, 163, 175)', // Î≤îÎ°Ä ÌÖçÏä§Ìä∏ ÏÉâÏÉÅÏùÑ ÌöåÏÉâÏúºÎ°ú Î≥ÄÍ≤Ω (TailwindÏùò gray-400Ïóê Ìï¥Îãπ)
                    usePointStyle: true,
                    pointStyle: 'rectRounded',
                    font: {
                        size: 12 // Ìè∞Ìä∏ ÌÅ¨Í∏∞ Ï°∞Ï†ï (ÌïÑÏöîÏóê Îî∞Îùº)
                    },
                    boxWidth: 15, // Î≤îÎ°Ä ÏïÑÏù¥ÏΩòÏùò ÎÑàÎπÑ
                    boxHeight: 15, // Î≤îÎ°Ä ÏïÑÏù¥ÏΩòÏùò ÎÜíÏù¥
                    generateLabels: (chart) => {
                        const originalLabels = ChartJS.defaults.plugins.legend.labels.generateLabels(chart);
                        
                        // Í≤ΩÍ∏∞ Ïπ®Ï≤¥ Í∏∞Í∞Ñ Î≤îÎ°Ä Ï∂îÍ∞Ä
                        originalLabels.push({
                            text: 'Í≤ΩÍ∏∞ Ïπ®Ï≤¥ Í∏∞Í∞Ñ',
                            fillStyle: 'rgba(255, 0, 0, 0.1)',
                            strokeStyle: 'rgba(255, 0, 0, 0.5)',
                            lineWidth: 0.5,
                            hidden: false,
                            index: originalLabels.length,
                            pointStyle: 'rectRounded',
                        });
                        
                        return originalLabels;
                    }
                },
                onClick: (e, legendItem, legend) => {
                    // Í≤ΩÍ∏∞ Ïπ®Ï≤¥ Í∏∞Í∞Ñ Î≤îÎ°Ä ÌÅ¥Î¶≠ Ïãú ÎèôÏûë Î∞©ÏßÄ
                    if (legendItem.text === 'Í≤ΩÍ∏∞ Ïπ®Ï≤¥ Í∏∞Í∞Ñ') return;
                    
                    // Í∏∞Ï°¥ Î≤îÎ°Ä ÌÅ¥Î¶≠ ÎèôÏûë Ïú†ÏßÄ
                    const index = legendItem.datasetIndex;
                    const ci = legend.chart;
                    if (ci.isDatasetVisible(index)) {
                        ci.hide(index);
                        legendItem.hidden = true;
                    } else {
                        ci.show(index);
                        legendItem.hidden = false;
                    }
                }
            },
            annotation: {   
                annotations: nberData.reduce((acc, item, index, array) => {
                    if (item.isRecession && (!array[index - 1] || !array[index - 1].isRecession)) {
                        const endDate =
                            array.slice(index).find((i) => !i.isRecession)?.date || array[array.length - 1].date
                        acc.push({
                            type: 'box',
                            xMin: item.date,
                            xMax: endDate,
                            backgroundColor: 'rgba(255, 0, 0, 0.1)',
                            borderColor: 'rgba(255, 0, 0, 0.5)',
                            borderWidth: 0.5,
                            drawTime: 'beforeDatasetsDraw',
                        })
                    }
                    return acc
                }, []),
            },
        },
    }), [isNormalized, selectedIndicators, nberData])

    const toggleNormalization = () => {
        setIsNormalized(!isNormalized)
    }

    return (
        <Card className="fixed inset-0 z-50 bg-gray-900 bg-opacity-75 flex items-center justify-center">
            <div className="bg-gray-800 p-6 rounded-lg w-full max-w-4xl">
                <CardHeader className="flex justify-between items-center">
                    <h3 className="text-xl font-semibold text-white">
                        ÏßÄÌëú ÎπÑÍµê Í∑∏ÎûòÌîÑ {isNormalized ? '(Ï†ïÍ∑úÌôîÎêú Í∞í)' : '(ÏõêÎûò Í∞í)'}
                    </h3>
                    <div>
                        <button
                            onClick={toggleNormalization}
                            className="text-gray-400 hover:text-white mr-4"
                        >
                            {isNormalized ? 'ÏõêÎûò Í∞í Î≥¥Í∏∞' : 'Ï†ïÍ∑úÌôîÎêú Í∞í Î≥¥Í∏∞'}
                        </button>
                        <button onClick={onClose} className="text-gray-400 hover:text-white">
                            Îã´Í∏∞
                        </button>
                    </div>
                </CardHeader>
                <CardContent>
                    <div style={{ height: '400px' }}>
                        {selectedIndicators.length > 0 ? (
                            <Line ref={handleChartRef} data={chartData} options={options} />
                        ) : (
                            <p>Îç∞Ïù¥ÌÑ∞Î•º Î∂àÎü¨Ïò§Îäî Ï§ëÏûÖÎãàÎã§...</p>
                        )}
                    </div>
                </CardContent>
            </div>
        </Card>
    )
}

// Îëê Ïª¥Ìè¨ÎÑåÌä∏Î•º Ìï®Íªò export
export { TimeSeriesChart, CompareChart }
