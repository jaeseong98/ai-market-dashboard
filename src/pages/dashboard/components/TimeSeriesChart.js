import React, { useEffect, useState, useMemo } from 'react'
import { Line } from 'react-chartjs-2'
import { Card, CardHeader, CardContent } from '../../../components/Card.js'
import { indicatorNames, indicatorColors } from '../../../helpers/indicators.js'
import {
    Chart as ChartJS,
    CategoryScale,
    LinearScale,
    PointElement,
    LineElement,
    Title,
    Tooltip,
    Legend,
    TimeScale,
    registerables,
} from 'chart.js'
import 'chartjs-adapter-date-fns'
import annotationPlugin from 'chartjs-plugin-annotation'
import { format, parseISO, isEqual, subYears } from 'date-fns'
import { ko } from 'date-fns/locale'
import { winsorizeData } from '../../../helpers/dataprocessing.js'

ChartJS.register(
    CategoryScale,
    LinearScale,
    PointElement,
    LineElement,
    Title,
    Tooltip,
    Legend,
    TimeScale,
    annotationPlugin,
    ...registerables,
)


// Í∏∞Ï°¥Ïùò TimeSeriesChart Ïª¥Ìè¨ÎÑåÌä∏
const TimeSeriesChart = ({ data, indicatorKey, nberData, onClose, isNormalized }) => {
    const [chartInstance, setChartInstance] = useState(null)
    const [showTrimmed, setShowTrimmed] = useState(false)
    const [startDate, setStartDate] = useState('')
    const [endDate, setEndDate] = useState('')
    const [dateRangeType, setDateRangeType] = useState('all')

    useEffect(() => {
        return () => {
            if (chartInstance) {
                chartInstance.destroy()
            }
        }
    }, [chartInstance])

    const handleChartRef = (ref) => {
        if (ref) {
            setChartInstance(ref.chartInstance)
        }
    }

    // ÌïÑÌÑ∞ÎßÅÎêú Îç∞Ïù¥ÌÑ∞ Í≥ÑÏÇ∞
    const filteredData = useMemo(() => {
        return data.filter(item => {
            const itemDate = new Date(item.DATA_YMD)
            const start = startDate ? new Date(startDate) : new Date(0)
            const end = endDate ? new Date(endDate) : new Date()
            return itemDate >= start && itemDate <= end
        })
    }, [data, startDate, endDate])

    // validDataÎ•º filteredData Í∏∞Î∞òÏúºÎ°ú ÏàòÏ†ï
    const validData = useMemo(() => {
        return filteredData
            .filter((item) => item[indicatorKey] !== undefined && item[indicatorKey] !== null)
            .sort((a, b) => new Date(a.DATA_YMD) - new Date(b.DATA_YMD))
    }, [filteredData, indicatorKey])

    // trimmedDataÎèÑ filteredData Í∏∞Î∞òÏúºÎ°ú Í≥ÑÏÇ∞
    const trimmedData = useMemo(() => winsorizeData(validData, indicatorKey), [validData, indicatorKey])

    const values = validData.map(item => parseFloat(item[indicatorKey]))
    const min = Math.min(...values)
    const max = Math.max(...values)
    const mean = values.reduce((sum, value) => sum + value, 0) / values.length
    const std = Math.sqrt(values.reduce((sum, value) => sum + Math.pow(value - mean, 2), 0) / values.length)
    const upperBound = mean + 3 * std
    const lowerBound = mean - 3 * std

    const normalizeValue = (value) => (value - min) / (max - min)

    const chartData = {
        labels: validData.map((item) => item.DATA_YMD),
        datasets: [
            {
                label: `${indicatorNames[indicatorKey]} (Ïù¥ÏÉÅÏπò Ï†úÍ±∞)`,
                data: trimmedData.map((item) => ({
                    x: item.DATA_YMD,
                    y: isNormalized ? normalizeValue(item[`${indicatorKey}_winsorized`]) : item[`${indicatorKey}_winsorized`]
                })),
                borderColor: 'rgb(255, 165, 0)',
                backgroundColor: 'rgba(255, 165, 0, 0.5)',
                borderWidth: 2, // ÏÑ† ÎëêÍªòÎ•º 1Î°ú ÏÑ§Ï†ï
                tension: 0.1,
                pointRadius: 1, // Ï†ê ÌÅ¨Í∏∞Î•º 1Î°ú Ï§ÑÏûÑ
                pointHoverRadius: 5, // Ìò∏Î≤Ñ Ïãú Ï†ê ÌÅ¨Í∏∞Î•º 3ÏúºÎ°ú Ï§ÑÏûÑ
                pointStyle: 'circle', // Ï†ê Ïä§ÌÉÄÏùºÏùÑ ÏõêÏúºÎ°ú Î≥ÄÍ≤Ω
                hidden: !showTrimmed,
            },
            {
                label: `${indicatorNames[indicatorKey]} (ÏõêÎ≥∏)`,
                data: validData.map((item) => isNormalized ? normalizeValue(parseFloat(item[indicatorKey])) : parseFloat(item[indicatorKey])),
                borderColor: 'rgb(135, 206, 235)',
                backgroundColor: 'rgba(135, 206, 235, 0.5)',
                borderWidth: 2, // ÏÑ† ÎëêÍªòÎ•º 1Î°ú ÏÑ§Ï†ï
                pointRadius: 0, // Ï†ê ÌÅ¨Í∏∞Î•º 1Î°ú Ï§ÑÏûÑ
                pointHoverRadius: 5, // Ìò∏Î≤Ñ Ïãú Ï†ê ÌÅ¨Í∏∞Î•º 3ÏúºÎ°ú Ï§ÑÏûÑ
                pointStyle: 'circle', // Ï†ê Ïä§ÌÉÄÏùºÏùÑ ÏõêÏúºÎ°ú Î≥Ä
            },
            {
                label: 'ÌèâÍ∑†',
                data: validData.map(() => isNormalized ? normalizeValue(mean) : mean),
                borderColor: 'rgb(255, 0, 0)',
                borderWidth: 2,
                borderDash: [5, 5],
                pointRadius: 0,
                fill: false,
            },
            {
                label: 'ÏÉÅÌïú (ÌèâÍ∑† + 3*ÌëúÏ§ÄÌé∏Ï∞®)',
                data: validData.map(() => isNormalized ? normalizeValue(upperBound) : upperBound),
                borderColor: 'rgb(0, 128, 0)',
                borderWidth: 2,
                borderDash: [5, 5],
                pointRadius: 0,
                fill: false,
            },
            {
                label: 'ÌïòÌïú (ÌèâÍ∑† - 3*ÌëúÏ§ÄÌé∏Ï∞®)',
                data: validData.map(() => isNormalized ? normalizeValue(lowerBound) : lowerBound),
                borderColor: 'rgb(0, 128, 0)',
                borderWidth: 2,
                borderDash: [5, 5],
                pointRadius: 0,
                fill: false,
            },
        ],
    }

    const options = {
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
            legend: {
                display: true,
                position: 'top',
                onClick: (e, legendItem, legend) => {
                    const index = legendItem.datasetIndex
                    const ci = legend.chart
                    if (ci.isDatasetVisible(index)) {
                        ci.hide(index)
                        legendItem.hidden = false
                    } else {
                        ci.show(index)
                        legendItem.hidden = true
                    }
                    setShowTrimmed(ci.isDatasetVisible(1))
                },
                labels: {
                    color: 'rgb(156, 163, 175)', // Î≤îÎ°Ä ÌÖçÏä§Ìä∏ ÏÉâÏÉÅÏùÑ ÌöåÏÉâÏúºÎ°ú Î≥ÄÍ≤Ω (TailwindÏùò gray-400Ïóê Ìï¥Îãπ)
                    usePointStyle: true,
                    pointStyle: 'rectRounded',
                    font: {
                        size: 12 // Ìè∞Ìä∏ ÌÅ¨Í∏∞ Ï°∞Ï†ï (ÌïÑÏöîÏóê Îî∞Îùº)
                    },
                    boxWidth: 15, // Î≤îÎ°Ä ÏïÑÏù¥ÏΩòÏùò ÎÑàÎπÑ
                    boxHeight: 15, // Î≤îÎ°Ä ÏïÑÏù¥ÏΩòÏùò ÎÜíÏù¥
                },
            },
            tooltip: {
                mode: 'index',
                intersect: false,
                callbacks: {
                    title: (context) => {
                        const date = new Date(context[0].parsed.x)
                        return format(date, 'yyyy-MM-dd', { locale: ko })
                    },
                    label: (context) => {
                        let label = context.dataset.label || ''
                        if (label) {
                            label += ': '
                        }
                        if (context.parsed.y !== null) {
                            label += context.parsed.y.toFixed(2)
                        }
                        return label
                    },
                    afterBody: (context) => {
                        const date = new Date(context[0].parsed.x)
                        const formattedDate = format(date, 'yyyy-MM-dd')
                        const nberItem = nberData.find((item) => isEqual(parseISO(item.date), parseISO(formattedDate)))
                        if (nberItem && nberItem.isRecession) {
                            return 'üü• Í≤ΩÍ∏∞ Ïπ®Ï≤¥ Í∏∞Í∞Ñ' // Îπ®Í∞ÑÏÉâ ÎÑ§Î™® Ïù¥Î™®ÏßÄ ÏÇ¨Ïö©
                        }
                        return ''
                    },
                },
            },
            annotation: {
                annotations: nberData.reduce((acc, item, index, array) => {
                    if (item.isRecession && (!array[index - 1] || !array[index - 1].isRecession)) {
                        const endDate =
                            array.slice(index).find((i) => !i.isRecession)?.date || array[array.length - 1].date
                        acc.push({
                            type: 'box',
                            xMin: item.date,
                            xMax: endDate,
                            backgroundColor: 'rgba(255, 0, 0, 0.1)',
                            borderColor: 'rgba(255, 0, 0, 0.3)',
                            drawTime: 'beforeDatasetsDraw',
                        })
                    }
                    return acc
                }, []),
            },
        },
        scales: {
            x: {
                type: 'time',
                time: {
                    unit: 'month',
                    displayFormats: {
                        month: 'yyyy-MM',
                    },
                },
                grid: {
                    display: false,  // xÏ∂ï Í≤©Ïûê ÏÑ† Ï†úÍ±∞
                },
                ticks: {
                    color: 'rgb(156, 163, 175)',
                    font: {
                        size: 11
                    }
                },
                title: {
                    display: true,
                    text: 'ÎÇ†Ïßú',
                    color: 'rgb(156, 163, 175)',
                },
                min: startDate || undefined,
                max: endDate || undefined,
            },
            y: {
                title: {
                    display: true,
                    text: isNormalized ? 'Ï†ïÍ∑úÌôîÎêú Í∞í' : 'Í∞í',
                },
                beginAtZero: isNormalized,
                min: isNormalized ? 0 : undefined,
                max: isNormalized ? 1 : undefined,
                grid: {
                    display: false,
                },
            },
        },
    }

    const handleDateRangeChange = (rangeType) => {
        setDateRangeType(rangeType)
        const now = new Date()
        
        switch (rangeType) {
            case '1y':
                setStartDate(format(subYears(now, 1), 'yyyy-MM-dd'))
                setEndDate(format(now, 'yyyy-MM-dd'))
                break
            case '3y':
                setStartDate(format(subYears(now, 3), 'yyyy-MM-dd'))
                setEndDate(format(now, 'yyyy-MM-dd'))
                break
            case '5y':
                setStartDate(format(subYears(now, 5), 'yyyy-MM-dd'))
                setEndDate(format(now, 'yyyy-MM-dd'))
                break
            case '10y':
                setStartDate(format(subYears(now, 10), 'yyyy-MM-dd'))
                setEndDate(format(now, 'yyyy-MM-dd'))
                break
            case 'all':
                setStartDate('')
                setEndDate('')
                break
            case 'custom':
                // customÏù∏ Í≤ΩÏö∞ ÌòÑÏû¨ ÏÑ†ÌÉùÎêú ÎÇ†Ïßú Ïú†ÏßÄ
                break
            default:
                // Ïïå Ïàò ÏóÜÎäî ÌÉÄÏûÖÏù∏ Í≤ΩÏö∞ Ï†ÑÏ≤¥ Í∏∞Í∞ÑÏúºÎ°ú ÏÑ§Ï†ï
                setDateRangeType('all')
                setStartDate('')
                setEndDate('')
                break
        }
    }

    const resetDateRange = () => {
        setDateRangeType('all')
        setStartDate('')
        setEndDate('')
    }

    return (
        <Card className="fixed inset-0 z-50 bg-gray-900 bg-opacity-75 flex items-center justify-center">
            <div className="bg-gray-800 p-6 rounded-lg w-full max-w-4xl">
                <CardHeader className="flex flex-col gap-3">
                    <div className="flex justify-between items-center">
                        <h3 className="text-xl font-semibold text-white">
                            {indicatorNames[indicatorKey]} ÏãúÍ≥ÑÏó¥ Í∑∏ÎûòÌîÑ
                        </h3>
                        <div className="flex items-center gap-4">
                            <button
                                onClick={() => setShowTrimmed(!showTrimmed)}
                                className="text-sm text-gray-400 hover:text-white"
                            >
                                {showTrimmed ? 'Ïù¥ÏÉÅÏπò Ï†úÍ±∞ Ïà®Í∏∞Í∏∞' : 'Ïù¥ÏÉÅÏπò Ï†úÍ±∞ Î≥¥Í∏∞'}
                            </button>
                            <button onClick={onClose} className="text-sm text-gray-400 hover:text-white">
                                Îã´Í∏∞
                            </button>
                        </div>
                    </div>
                    <div className="flex items-center gap-2 text-sm">
                        <select 
                            value={dateRangeType}
                            onChange={(e) => handleDateRangeChange(e.target.value)}
                            className="bg-gray-700 text-white px-2 py-1 rounded text-sm"
                        >
                            <option value="custom">ÏßÅÏ†ë ÏÑ†ÌÉù</option>
                            <option value="1y">ÏµúÍ∑º 1ÎÖÑ</option>
                            <option value="3y">ÏµúÍ∑º 3ÎÖÑ</option>
                            <option value="5y">ÏµúÍ∑º 5ÎÖÑ</option>
                            <option value="10y">ÏµúÍ∑º 10ÎÖÑ</option>
                            <option value="all">Ï†ÑÏ≤¥ Í∏∞Í∞Ñ</option>
                        </select>
                        {dateRangeType === 'custom' && (
                            <>
                                <input
                                    type="date"
                                    value={startDate}
                                    onChange={(e) => setStartDate(e.target.value)}
                                    className="bg-gray-700 text-white px-2 py-1 rounded text-sm"
                                />
                                <span className="text-white text-sm">~</span>
                                <input
                                    type="date"
                                    value={endDate}
                                    onChange={(e) => setEndDate(e.target.value)}
                                    className="bg-gray-700 text-white px-2 py-1 rounded text-sm"
                                />
                            </>
                        )}
                        <button
                            onClick={resetDateRange}
                            className="text-sm text-gray-400 hover:text-white px-2 py-1"
                        >
                            Ï¥àÍ∏∞Ìôî
                        </button>
                    </div>
                </CardHeader>
                <CardContent>
                    <div style={{ 
                        height: '400px', 
                        backgroundColor: 'rgb(17, 24, 39)',  // Î∞∞Í≤ΩÏÉâ Ï∂îÍ∞Ä
                        borderRadius: '0.5rem',              // Î™®ÏÑúÎ¶¨ Îë•Í∏ÄÍ≤å
                        padding: '1rem'                      // Ìå®Îî© Ï∂îÍ∞Ä
                    }}>
                        <Line data={chartData} options={options} ref={handleChartRef} />
                    </div>
                </CardContent>
            </div>
        </Card>
    )
}

// ÏÉàÎ°úÏö¥ CompareChart Ïª¥Ìè¨ÎÑåÌä∏
const CompareChart = ({ data, selectedIndicators, nberData, onClose }) => {
    const [isNormalized, setIsNormalized] = useState(false)
    const [startDate, setStartDate] = useState('')
    const [endDate, setEndDate] = useState('')
    const [dateRangeType, setDateRangeType] = useState('all')

    // ÌïÑÌÑ∞ÎßÅÎêú Îç∞Ïù¥ÌÑ∞ Í≥ÑÏÇ∞
    const filteredData = useMemo(() => {
        return data.filter(item => {
            const itemDate = new Date(item.DATA_YMD)
            const start = startDate ? new Date(startDate) : new Date(0)
            const end = endDate ? new Date(endDate) : new Date()
            return itemDate >= start && itemDate <= end
        })
    }, [data, startDate, endDate])

    // Ï∞®Ìä∏ Îç∞Ïù¥ÌÑ∞ ÏÉùÏÑ±
    const chartData = useMemo(() => ({
        labels: filteredData.map(item => item.DATA_YMD),
        datasets: selectedIndicators.map(indicator => ({
            label: indicatorNames[indicator],
            data: filteredData.map(item => ({
                x: item.DATA_YMD,
                y: isNormalized 
                    ? (item[indicator] - Math.min(...filteredData.map(d => d[indicator]))) / 
                      (Math.max(...filteredData.map(d => d[indicator])) - Math.min(...filteredData.map(d => d[indicator])))
                    : item[indicator]
            })),
            borderColor: indicatorColors[indicator],
            backgroundColor: `${indicatorColors[indicator]}50`,
            borderWidth: 2,
            tension: 0.1,
            pointRadius: 1,
            pointHoverRadius: 5,
        }))
    }), [filteredData, selectedIndicators, isNormalized])

    // Ï∞®Ìä∏ ÏòµÏÖò ÏÑ§Ï†ï
    const options = useMemo(() => ({
        responsive: true,
        maintainAspectRatio: false,
        scales: {
            x: {
                type: 'time',
                time: {
                    unit: 'month',
                    displayFormats: {
                        month: 'yyyy-MM',
                    },
                },
                grid: {
                    display: false,
                },
                min: startDate || undefined,
                max: endDate || undefined,
                ticks: {
                    color: 'rgb(156, 163, 175)',
                    font: {
                        size: 11
                    }
                },
            },
            y: {
                grid: {
                    color: 'rgba(255, 255, 255, 0.1)',
                },
                ticks: {
                    color: 'rgb(156, 163, 175)',
                }
            }
        },
        plugins: {
            tooltip: {
                mode: 'index',
                intersect: false,
                callbacks: {
                    title: (context) => {
                        const date = new Date(context[0].parsed.x)
                        return format(date, 'yyyy-MM-dd', { locale: ko })
                    },
                    label: function(context) {
                        const indicator = selectedIndicators[context.datasetIndex];
                        const value = context.parsed.y;
                        return `${indicatorNames[indicator]}: ${value.toFixed(4)}`;
                    },
                    afterBody: (context) => {
                        const date = new Date(context[0].parsed.x);
                        const formattedDate = format(date, 'yyyy-MM-dd');
                        const nberItem = nberData.find((item) => isEqual(parseISO(item.date), parseISO(formattedDate)));
                        if (nberItem && nberItem.isRecession) {
                            return 'üü• Í≤ΩÍ∏∞ Ïπ®Ï≤¥ Í∏∞Í∞Ñ';
                        }
                        return '';
                    }
                }
            },
            legend: {
                position: 'top',
                labels: {
                    color: 'rgb(156, 163, 175)',
                    usePointStyle: true,
                    pointStyle: 'rectRounded',
                    font: {
                        size: 12
                    },
                    boxWidth: 15,
                    boxHeight: 15,
                    generateLabels: (chart) => {
                        const originalLabels = ChartJS.defaults.plugins.legend.labels.generateLabels(chart);
                        originalLabels.push({
                            text: 'Í≤ΩÍ∏∞ Ïπ®Ï≤¥ Í∏∞Í∞Ñ',
                            fillStyle: 'rgba(255, 0, 0, 0.1)',
                            strokeStyle: 'rgba(255, 0, 0, 0.5)',
                            lineWidth: 0.5,
                            hidden: false,
                            index: originalLabels.length,
                            pointStyle: 'rectRounded',
                        });
                        return originalLabels;
                    }
                },
                onClick: (e, legendItem, legend) => {
                    if (legendItem.text === 'Í≤ΩÍ∏∞ Ïπ®Ï≤¥ Í∏∞Í∞Ñ') return;
                    const index = legendItem.datasetIndex;
                    const ci = legend.chart;
                    if (ci.isDatasetVisible(index)) {
                        ci.hide(index);
                        legendItem.hidden = true;
                    } else {
                        ci.show(index);
                        legendItem.hidden = false;
                    }
                }
            },
            annotation: {   
                annotations: nberData.reduce((acc, item, index, array) => {
                    if (item.isRecession && (!array[index - 1] || !array[index - 1].isRecession)) {
                        const endDate =
                            array.slice(index).find((i) => !i.isRecession)?.date || array[array.length - 1].date
                        acc.push({
                            type: 'box',
                            xMin: item.date,
                            xMax: endDate,
                            backgroundColor: 'rgba(255, 0, 0, 0.1)',
                            borderColor: 'rgba(255, 0, 0, 0.5)',
                            borderWidth: 0.5,
                            drawTime: 'beforeDatasetsDraw',
                        })
                    }
                    return acc
                }, []),
            }
        }
    }), [startDate, endDate, nberData, selectedIndicators])

    const handleDateRangeChange = (rangeType) => {
        setDateRangeType(rangeType)
        const now = new Date()
        
        switch (rangeType) {
            case '1y':
                setStartDate(format(subYears(now, 1), 'yyyy-MM-dd'))
                setEndDate(format(now, 'yyyy-MM-dd'))
                break
            case '3y':
                setStartDate(format(subYears(now, 3), 'yyyy-MM-dd'))
                setEndDate(format(now, 'yyyy-MM-dd'))
                break
            case '5y':
                setStartDate(format(subYears(now, 5), 'yyyy-MM-dd'))
                setEndDate(format(now, 'yyyy-MM-dd'))
                break
            case '10y':
                setStartDate(format(subYears(now, 10), 'yyyy-MM-dd'))
                setEndDate(format(now, 'yyyy-MM-dd'))
                break
            case 'all':
                setStartDate('')
                setEndDate('')
                break
            case 'custom':
                break
            default:
                setDateRangeType('all')
                setStartDate('')
                setEndDate('')
                break
        }
    }

    const resetDateRange = () => {
        setDateRangeType('all')
        setStartDate('')
        setEndDate('')
    }

    return (
        <Card className="fixed inset-0 z-50 bg-gray-900 bg-opacity-75 flex items-center justify-center">
            <div className="bg-gray-800 p-6 rounded-lg w-full max-w-4xl">
                <CardHeader className="flex flex-col gap-3">
                    <div className="flex justify-between items-center">
                        <h3 className="text-xl font-semibold text-white">
                            ÏßÄÌëú ÎπÑÍµê Í∑∏ÎûòÌîÑ {isNormalized ? '(Ï†ïÍ∑úÌôîÎêú Í∞í)' : '(ÏõêÎûò Í∞í)'}
                        </h3>
                        <div className="flex items-center gap-4">
                            <button
                                onClick={() => setIsNormalized(!isNormalized)}
                                className="text-sm text-gray-400 hover:text-white"
                            >
                                {isNormalized ? 'ÏõêÎûò Í∞í Î≥¥Í∏∞' : 'Ï†ïÍ∑úÌôîÎêú Í∞í Î≥¥Í∏∞'}
                            </button>
                            <button onClick={onClose} className="text-sm text-gray-400 hover:text-white">
                                Îã´Í∏∞
                            </button>
                        </div>
                    </div>
                    <div className="flex items-center gap-2 text-sm">
                        <select 
                            value={dateRangeType}
                            onChange={(e) => handleDateRangeChange(e.target.value)}
                            className="bg-gray-700 text-white px-2 py-1 rounded text-sm"
                        >
                            <option value="custom">ÏßÅÏ†ë ÏÑ†ÌÉù</option>
                            <option value="1y">ÏµúÍ∑º 1ÎÖÑ</option>
                            <option value="3y">ÏµúÍ∑º 3ÎÖÑ</option>
                            <option value="5y">ÏµúÍ∑º 5ÎÖÑ</option>
                            <option value="10y">ÏµúÍ∑º 10ÎÖÑ</option>
                            <option value="all">Ï†ÑÏ≤¥ Í∏∞Í∞Ñ</option>
                        </select>
                        {dateRangeType === 'custom' && (
                            <>
                                <input
                                    type="date"
                                    value={startDate}
                                    onChange={(e) => setStartDate(e.target.value)}
                                    className="bg-gray-700 text-white px-2 py-1 rounded text-sm"
                                />
                                <span className="text-white text-sm">~</span>
                                <input
                                    type="date"
                                    value={endDate}
                                    onChange={(e) => setEndDate(e.target.value)}
                                    className="bg-gray-700 text-white px-2 py-1 rounded text-sm"
                                />
                            </>
                        )}
                        <button
                            onClick={resetDateRange}
                            className="text-sm text-gray-400 hover:text-white px-2 py-1"
                        >
                            Ï¥àÍ∏∞Ìôî
                        </button>
                    </div>
                </CardHeader>
                <CardContent>
                    <div style={{ height: '400px', backgroundColor: 'rgb(17, 24, 39)', borderRadius: '0.5rem', padding: '1rem' }}>
                        {selectedIndicators.length > 0 ? (
                            <Line data={chartData} options={options} />
                        ) : (
                            <p className="text-center text-gray-400">Îç∞Ïù¥ÌÑ∞Î•º Î∂àÎü¨Ïò§Îäî Ï§ëÏûÖÎãàÎã§...</p>
                        )}
                    </div>
                </CardContent>
            </div>
        </Card>
    )
}

// Îëê Ïª¥Ìè¨ÎÑåÌä∏Î•º Ìï®Íªò export
export { TimeSeriesChart, CompareChart }
